// Generated by CoffeeScript 1.7.1
define([], function() {
  var keys, me;
  keys = function(obj) {
    var func;
    if (!Object.keys) {
      func = function(obj) {
        var hasOwnProperty, prop, result;
        hasOwnProperty = Object.prototype.hasOwnProperty;
        if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
          throw new TypeError('Object.keys called on non-object');
          return;
        }
        result = [];
        for (prop in obj) {
          if (hasOwnProperty.call(obj, prop)) {
            result.push(prop);
          }
        }
        return result;
      };
      return func(obj);
    } else {
      return Object.keys(obj);
    }
  };
  me = {
    version: '{{version}}',
    models: '{{models}}',
    validators: {
      required: function(value) {
        if (value === null || value === void 0) {
          return false;
        } else {
          return true;
        }
      },
      match: function(value, parameters) {
        var regExp;
        regExp = parameters[0];
        return null !== value && ('' !== value ? regExp.test(value) : true);
      }
    },
    attach: function(App, names) {
      var name, thiz, _i, _len;
      thiz = this;
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        App[name] = DS.Model.extend(this.models[name].model);
        App[name].reopen({
          errors: {},
          validate: function() {
            var message, option, options, parameters, path, result, type, validations, validator, _j, _k, _len1, _len2, _ref;
            validations = me.models[name].validations;
            _ref = keys(validations);
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              path = _ref[_j];
              options = validations[path];
              for (_k = 0, _len2 = options.length; _k < _len2; _k++) {
                option = options[_k];
                type = option.type;
                message = option.message;
                parameters = option.parameters;
                validator = thiz.validators[type];
                result = validator(this.get(path), parameters);
                if (!result) {
                  this.set('errors.' + path, message);
                }
              }
            }
          }
        });
        App[name + 'Adapter'] = DS.RESTAdapter.extend(this.models[name].adapter);
        App[name + 'Serializer'] = DS.RESTSerializer.extend(this.models[name].serializer);
      }
    },
    auth: {
      signup: function(user) {
        var data, url;
        url = '{{url_signup}}';
        data = JSON.stringify({
          user: user.toJSON()
        });
        return new Ember.RSVP.Promise(function(resolve, reject) {
          return $.ajax({
            type: 'POST',
            contentType: 'application/json; charset=utf-8',
            url: url,
            data: data,
            dataType: 'json'
          }).done(function(data) {
            return resolve(data);
          }).fail(function(data) {
            return reject(data.responseText);
          });
        });
      },
      login: function(user) {
        var url;
        url = '{{url_login}}';
        if (typeof user.toJSON === 'function') {
          user = user.toJSON();
        }
        return $.post(url, {
          user: user
        });
      },
      check: function() {
        var url;
        url = '{{url_check}}';
        return new Ember.RSVP.Promise(function(resolve, reject) {
          return $.get(url).done(function(data) {
            return resolve(data);
          }).fail(function(data) {
            return resolve(null);
          });
        });
      }
    }
  };
  return me;
});
