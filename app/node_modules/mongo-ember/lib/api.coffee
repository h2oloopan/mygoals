mongoose = require 'mongoose'
utils = require 'mongoose/lib/utils'
me = require './mongo-ember'

wrap = (input, wrapper) ->
	output = {}
	output[wrapper] = input
	return output

unwrap = (input, ids) ->
	key = Object.keys(input)[0]
	output = input[key]
	#remove null keys for the use of mongoose
	for key in Object.keys output
		if output[key] == null
			delete output[key]

	ids = ids || []
	for id in ids
		output[id] = mongoose.Types.ObjectId output[id]
	return output

crud = (app, url, name) ->
	model = mongoose.models[name]
	cname = utils.toCollectionName name

	#c
	app.post url, (req, res) ->
		obj = unwrap req.body
		obj = new model obj
		obj.save (err, result) ->
			if err
				res.send 500, err.message
			else
				res.send 201, wrap result, name

	#r
	#r all
	app.get url, (req, res) ->
		model.find {}, (err, result) ->
			if err
				res.send 500, err.message
			else
				res.send 200, wrap result, cname
	
	#r one
	app.get url + '/:id', (req, res) ->
		id = req.params.id
		model.findById id, (err, result) ->
			if err
				res.send 500, err.message
			else
				res.send 200, wrap result, name

	#u
	app.put url + '/:id', (req, res) ->
		id = req.params.id
		obj = unwrap req.body
		model.findByIdAndUpdate id, obj, (err, result) ->
			if err
				res.send 500, err.message
			else
				res.send 200, wrap result, name

	#d
	app.delete url + '/:id', (req, res) ->
		id = req.params.id
		#why find and remove? to make sure cascading removal hooks are called
		model.findById id, (err, result) ->
			if err
				res.send 500, err.message
			else if !result?
				res.send 500, 'No matching item to delete'
			else
				result.remove (err, result) ->
					if err
						res.send 500, err.message
					else
						res.send 204




api = module.exports =
	bind: (app) ->
		root = '/' + (me.settings.namespace || '')	
		models = mongoose.models
		for name of models
			model = models[name]
			cname = utils.toCollectionName name
			url = root + '/' + cname
			crud app, url, name

			
		return